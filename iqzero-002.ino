// IQ Zero (fka Wurm): Procedurally-generate Genetic Algorithm Autonomous Micro Robot
// For ATTiny85 and the Arduino environment
// 2016 @diemastermonkey
// 
// ---------------------------------------------------------------------------------
// Memo
// ---------------------------------------------------------------------------------
// REALLY ugly lab prototype - sorry for the mess folks, cleaner revs in the works!
// Yes I know it needs Major Refactoring. :\ -DMM
// ---------------------------------------------------------------------------------
//

// #include <EEPROM.h>    // For storing top GA later?
// V = EEPROM.read(Addr); EEPROM.write(Addr, V);

// GA Data Structures
// Static properties of a GA (all others are procgen'd)
// This instance is always the one under test
int iGASeed = 1;       // Base seed used for GA's program
int iGALength = 1;     // How many instructions in GA's program
int iGAStepSize = 1;   // How many 'instructions' advanced per cycle
// i.e. how many rands skipped                                                
int iGAScore = 0;                        
// These exist only for the GA under test
int iGACmd = -1;        // Actual "program command" value
int iGAPin = 2;         // General-purpose 'pointing at a pin' register
int iGAIn = -1;         // Single-value input/output registers
int iGAOut = -1;        
int iGALast= -1;        // Last value generated by randgen
int iGAStep = 0;        // Current step in test GA's 'program'

// For the zoo
int iGA[16][4];          // A zoo of GAs, and their 4 properties
int SEED=0, LENGTH=1, STEPSIZE=2, SCORE=3;  // For easier array syntax

// For entire sim - err, not sim, cause this is real :)
int iZooIndex = 0;         // Which GA from zoo currently being tested
int iZooTotal = 3;         // How many total in zoo i.e. population size
int iTestCyclesMax = 128;  // How many 'program instruction runs' per sim run
int iTestCycles = 0;       // Current test cycle "charge" style reverse counter
int iTestProgramDie = 32;  // How many different program values ie randgen die sides
int iStepSizeMax = iTestCyclesMax / 2
; // /2 to produce repeatable 'ga programs'

// Pins available to the GA
int iPins[] = {
  0, 1, 2, 3, 4, A1, A2, A3};
int iPinsMax = 7;          // Fast for frequent use
// Minimal structural 'hints'
int iServoMin = 20;
int iServoMax = 120;              // A hint used as mod on servo cmds
int iServoCharge = -1;            // Set high then charge, set low on 0 then -1 to disable
int iServoPin = 0;                // For normalization only, GA must discover what's what
int iLedPin = 3;                  // Diags
int iContactPin = 1;              // Trigger switch or contact sensor pin
int iSensorPin = 4;               // Currently a PIR (DIGITAL) sends high while motion
// "Environment" state stuff
int iSensorLast = -1;             // Last value from sensor for up/down compares
int iServoBonus = 0;              // Set to "TestCycleMax" each cycle, decrement for each servo, add at end

// Run-once setup
void setup () {
  // Attempt to really randomize from analog inputs
  pinMode (A1, INPUT); 
  pinMode (A2, INPUT); 
  pinMode (A3, INPUT);
  // Crudely init the first (ZooTotal) GA's seeds  
  // Bonus: Keep repeating while switch down, help randomize!
  int iDone = 0;
  while (iDone == 0) {
    for (int i=0; i <= iZooTotal; i++) {
      // Ineffective:
      randomSeed (analogRead(A0) + 6552 + micros());    // sometimes i salt for test
      iGA[i][SEED] = random(65536);
      iGA[i][LENGTH] = 32 + random(64); // WARN: Hardwired program len range
      iGA[i][STEPSIZE] = 1;    // NERFED // + random (2);     // Also    
    }
    if (digitalRead (iContactPin) == HIGH) {
      iDone = false;
    } else {
      iDone = true;
    }
  }

  fnGAPrep (0);    // Gotta start somewhere
  iTestCycles = iTestCyclesMax;  // Charge for test run
  delay(300);    // time to get out of its way!
}

// Main
// Run each GA's program for fixed x cycles
// Interrupt with fitness tests each round
void loop () {  

  // Discharge test cycles, or handle next testee, or bake off
  iTestCycles--;
  if (iTestCycles < 0) {
    // Charge for next series of runs asap
    iTestCycles = iTestCyclesMax;

    // This GA's run complete, update it's score, including bonus
    // of any leftover servo budget it didn't use (shouldn't be negative but, maybe?)
    // Note: NO BONUS if your score is less than the bonus!
    if (iGAScore > iServoBonus) { 
      iGAScore += iServoBonus;
    }    
    iGA[iZooIndex][SCORE] = iGAScore;
    // Go to next in zoo
    iZooIndex++;
//    fnFlash (iZooIndex, 50);

    // All zoo GAs tested: Select best performer
    if (iZooIndex >= iZooTotal) {
      iZooIndex = 0;
      // Select highest score
      int iHighScore, iHighIndex;
      for (int i=0; i < iZooTotal; i++) {
        if (iGA[i][SCORE] > iHighScore) {
          iHighScore = iGA[i][SCORE];            // Tha new winna!
          iHighIndex = i;
        }
      }  // End for 

      // Copy winner to all slots, then mutate all but 0th slot
      // To do: store winner in eeprom      
      for (int field=0; field < 4; field++) {
        iGA[0][field] = iGA[iHighIndex][field];    // Copy winner to 0th cage
      }
      iGA[0][SCORE] = 0;              // Clear its score, that's per-sesh

      for (int index=1; index < iZooTotal; index++) {  // Iterate all other cages in zoo
        for (int field=0; field < 4; field++) {         // Iterate fields of each GA
          iGA[index][field] = iGA[0][field];      // Just dupe 0th
        }
        // Mutate children probably
        // Amusingly, we need to re-seed to an unassociated value first! :)
        randomSeed (millis() + analogRead (A0));
          int rfield = random(4);                // WARN: Hardwired field
          if (rfield != 0) {                     // Seed change VERY rare
            int iTemp = iGA[index][rfield] + random(3) - 1;
            if (iTemp >= 1) {                    // No values smaller than this allowed!
              iGA[index][rfield] = iTemp;      // Add rand value if safe to do so
            }            
          } else {
            // Seed changes likely disastrous
            // if (random(2) == 0) {
              iGA[index][SEED] = random(65536);  // Actual new seed, likely disastrous
            // }
          }        // End else
          
          // Sanity checks where necessary
          // if (iGA[index][STEPSIZE] > iStepSizeMax) { iGA[index][STEPSIZE] = iStepSizeMax; }
          // KLUDGE NERF
          iGA[index][STEPSIZE] = 1;
          
      }              // End for (copy mutants)

      // Reset for next cycle of tests
      iZooIndex = 0;      
      // Indicate zoo cycle complete by flashing out winner's og index
      delay (50);
      fnFlash (iHighIndex + 1, 200);
      delay (25);                
    }                         // End 'if gt zoo total' all zoo iterated

    // Prep the new zoo victim for test 
    fnGAPrep (iZooIndex);
  }                          // End 'if cycles < 1' (cycles exhausted)

  // Handle current testee's "program step" (with wraparound)
  iGAStep++;
  if (iGAStep > iGALength) {    // Wraparound GA's program...
    iGAStep = 0;
    randomSeed (iGASeed);       // ...by reseeding
  }

  // Get current program instruction from the PRNG
  iGACmd = fnProcGenAdvance (iGA[iZooIndex][STEPSIZE]);

  // Execute the command (iTestProgramDie different types)
  switch (iGACmd) {
    // Case 0 (+?) - Do Nothing         
  case 0: 
    // Set Out to random value    
    break;
  case 1: 
    fnServoTask (iGAPin, iGAOut);          // (NEW: DEFAULT SERVO TASK FOR EMPTY INSTRUCTIONS!)
    break;      
    // Set 'pin' to value of in      
  case 2: 
    iGAPin = iGAIn; 
    break;      
    
  // Increment in
  case 4:
    iGAIn++;
    break;
  // Out to value of in
  case 3: 
    iGAOut = iGAIn; 
    break;      

  // Assignments of iGALast/iGAStep/ServoBonus etc
  case 5: 
    iGAIn = iGALast; 
    break;
  case 6: 
    iGAIn = iServoBonus;     // Set in to the current servo budget bonus
    break;
  case 7: 
    iGAPin = iGALast; 
    break;
    // Uses of its own step counter    
  case 8: 
    iGAIn = iGAStep; 
    break;
  case 9: 
    iGAIn = iGAIn % iGAStep; 
    break;
  case 10: 
    iGAOut = iGAStep; 
    break;      
  case 11:           // Increment out by current step
    iGAOut += iGAStep; 
    break;     

    // Pin changess
  case 12: 
    iGAPin++; 
    break;
  case 13: 
    iGAPin--; 
    break;    
  case 14: 
    iGAPin = iGALast; 
    break;
  case 15: 
    iGAOut++;        // Simple counter in GAOut
    break;

  // CONDITIONALS
  // 'skip next cmd if In gt Out'
  case 16:
    if (iGAIn > iGAOut) { 
      fnProcGenAdvance (iGA[iZooIndex][STEPSIZE]);  // discard next cmd
    }
    break;

  // 'skip next cmd if In lt Out' (opposite)
  case 17:
    if (iGAIn < iGAOut) { 
      fnProcGenAdvance (iGA[iZooIndex][STEPSIZE]);  // discard next cmd
    }  
    break;


  // Bonus "training wheels" easy servo task
  // Will happen anyways w/SmartWrite to servopin, 
  // but this doesn't require finding servopin
  case 18:
    fnServoTask (iServoPin, iGAOut); 
    break;
    
  case 19:   // Add own score to output
    iGAOut += iGAScore;
    break;
    
  case 20:   // Return to top if no score (should be handy)
    if (iGAScore < 2) {
      iGAStep = iGALength;    // Simply await wraparound      
    }
    break;
        

  //  Traditional inputs/outputs to/from pins
  case 21:   // Simple 'out' to 'pin' (NEW: No longer allowed to blink Status LED)
//    if (iPins[iGAPin] != iLedPin) {
    if (iGAPin != iLedPin) {          // In this one case, iPins[3] is also value 3
      fnSmartWrite (iGAPin, iGAOut);
    }
    break;

  case 22:   // Simple in from pin
    iGAIn += fnSmartRead (iGAPin);
    break;
    
  case 23:   // Accumulator version of in from pin
    iGAIn += fnSmartRead (iGAPin);
    break;

  // Skip (discard) one instruction
  case 24: 
    fnProcGenAdvance (iGA[iZooIndex][STEPSIZE]);
    break;

  // Skip "iGAOut mod Stepsize" instructions
  case 25:
    fnProcGenAdvance (iGAOut % iGA[iZooIndex][STEPSIZE]);
    break;
    
  // Read next instruction into GAIn, skipping it 
  case 26:
   iGAIn = fnProcGenAdvance (iGA[iZooIndex][STEPSIZE]);
   break;

  // Loop own program by jumping to actual bottom
  case 30:   
    iGAStep = iGALength;    // Simply await wraparound
    break;

  // Jump to own last command, which executes before wrap
  case 31:
    iGAStep = iGALength - 1;   // Last command actually runs if time
    break;            
  }                            // End big ugly switch

  //
  //
  // IMPORTANT - ACCUMULATE ANY SCORE BY CHECKING SENSORS, ETC
  // CANNOT happen in between cycles, as events are spurious and short
  iGAScore += fnScoreLive();
}                                  // End (main) loop

// Prep (arg index) GA from the zoo for a test run (and seed randgenerator)
// Thus a whole zoo is simply an array of seeds, lengths and steps.
void fnGAPrep (int argIndex) {    
  iGASeed = iGA[argIndex][SEED];  // Superfluous
  iGALength = iGA[argIndex][LENGTH];
  iGAStepSize = iGA[argIndex][STEPSIZE];
  iGAScore = 0;                  // Note score is reset each run
  iServoBonus = iTestCyclesMax;  // Recharge servo bonus
  iGAStep = 0;                   // Ditto
  // Init randgen with this GA's seed       
  randomSeed (iGASeed);           
}

// Return the xth random value from the generator
// with 1, it's just like a normal die, but any more
// is 'fast forwarding' the procgen - like skipping steps 
// in program. Returns within range of iTestProgramDie.
// Also updates 'last' buffer
int fnProcGenAdvance (int iArgStepSize) {
  for (int i=0; i < iArgStepSize; i++) {
    iGALast = random (iTestProgramDie); 
  }
  return (iGALast); 
}

// fnScoreLive: In-cycle tests for accumulating score during test
// returns a value to be *added* to the GA's score, thus supporting
// penalties later. Use 0 for no bonus.
int fnScoreLive (void) {
  int iScore = 0;
  int iTemp = 0;

  // if switch  pressed (*right now*), big points
  pinMode (iContactPin, INPUT);          // Always needed as GA may change?
  if (digitalRead (iContactPin) == HIGH) {
    iScore += 10;
  }

  // Sensor test, atm an LDR - more light means lower resistance
  pinMode (iSensorPin, INPUT);  
  // Example for an LDR i.e. "analog value changed"
  // iTemp = int (analogRead (iSensorPin) / 10);  
  
  // For digital PIR that sends continuous HIGH while motion detect
  iTemp = digitalRead(iSensorPin);  
  if (iTemp == HIGH) { 
    iScore += 5;                       // Doubled to ensure it weighs more than servo bonus
    // DEBUG
    fnFlash (1, 1);
  }
  iSensorLast = iTemp;                // May be used by GA

  //
  // Insert more tests here
  //
  return (iScore);
}

// SmartWrite - Write arg data to (normalized) arg pin (of pins array) 
// by the means expected by that pin. Squahes any arg pin index into 
// a value appropriate for the array of known pins.
void fnSmartWrite (int iArgPinIndex, int iArgData) {
  // Normalize the pin argument to be from 0 to iPinsMax
  int iPinIndex = iArgPinIndex / iPinsMax;
  int iPin = iPins[iPinIndex];          // Faster    
  pinMode (iPin, OUTPUT);              // Must as GA may have changed

  // Task the servo if it's one of those pins
  //  if (iPin == iServoPin) {
  // KLUDGETEST for two servos
  if (iPin == iServoPin || iPin == 2) {   
    fnServoTask (iPin, iArgData / iServoMax);  // Baby steps: Constrain to sorta servo range
    return;
  }

  // Else, treat as routine digital or analog
  if (iPinIndex < 5) {                  // First 4 in array are digital
    if (iArgData % 2 == 0) {               // Treat even/odd as high/low
      digitalWrite (iPin, HIGH);
    } 
    else {
      digitalWrite (iPin, LOW);
    }
  } 
  else {                                 // Upper 3 in array are analog
    analogWrite (iPin, iArgData);  // Simple!
  }                                      // End if
}                                        // End function

// SmartRead - Just like SmartWrite but reads, returns result
int fnSmartRead (int iArgPinIndex) {
  // Normalize the pin argument to be from 0 to iPinsMax
  int iPinIndex = abs (iArgPinIndex % iPinsMax);
  int iPin = iPins[iPinIndex];        // Faster
  pinMode (iPin, OUTPUT);  // Must as GA may change
  if (iPinIndex < 5) {                
    return (digitalRead(iPin));
  } 
  else {                               
    return (analogRead (iPin));
  }  
}

// Init servo to go to destination i (60=0' 280=180
// TO DO: Swap kludge* for 'fnServoProcess' nonblocking
void fnServoTask (int iArgPin, int i) {
  iServoCharge = i;      // Charge counter and send high to servo
  iServoBonus--;        // Charge GA's bonus for the servo activity
  // Training wheels: Add minimum servo value
  //  iServoCharge += iServoMin;
  digitalWrite (iArgPin, HIGH);  
  // KLUDGE -v
  delayMicroseconds (i);          // KLUDGE FIX TEST
  digitalWrite (iArgPin, LOW);
  delayMicroseconds(20000);          // KLUDGE FIX TEST * 
}

// Process servo if necessary (nonblocking - disused, reinstsate!)
void fnServoProcess () {
  if (iServoCharge == -1) { 
    return; 
  }      // Nothing to do
  iServoCharge--;                          // Decrement charge
  if (iServoCharge == 0) {
    digitalWrite (iServoPin, LOW);             // Discharged, send low to servo
    iServoCharge = -1;                     // Done, disable countdown
  }
}

// Simple flasher for status...es. Takes fractional seconds!
void fnFlash (int iTimes, float iDelaySeconds) {
  pinMode (iLedPin, OUTPUT);  
  int iDelay = 10000 * iDelaySeconds;
  for (int i=0; i < iTimes; i++) {
    digitalWrite (iLedPin, HIGH);
    delayMicroseconds (iDelay);
    digitalWrite (iLedPin, LOW);
    delayMicroseconds (iDelay);
  }
}

