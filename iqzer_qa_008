/* ------------------------------------------------------------------------
 IQ Zero (fka Wurm)
 Procedurally-Generated Genetic Algorithm Autonomous Micro Robot
 For ATTiny85 and the Arduino environment
 Winner of the Adafruit/Hackaday Pi Zero Contest!
 2016 @diemastermonkey (with special thanks to Charles "Chucky D" Darwin)   
 ------------------------------------------------------------------------
 */

/* ------------------------------------------------------------------------
 Memo
 ------------------------------------------------------------------------
 v 0.08  Finally a bit more wieldy GA structure. Greatly simplified 
 'internal logic', only a simple test cycle implemented.
 
 Next: Increased emphasis on curves (retreating to Karl Simms?) - 
 because I want to explore possible "toy" applications.
 
 v 0.06  Completely refactored! Timer-based (not step-based) test cycle,
 fewer activities in mainline, fewer prng accesses, LESS flexibility for
 fields and mutations, but safer.
 */
 
/* ------------------------------------------------------------------------
 Tuning
 ------------------------------------------------------------------------
 */
int iZooTotal = 6;                // Total GAs in population
long lRandMax = 256;              // Range of most rand outs
unsigned long lRunTimeMS =  500;  // Lifetime of each GA in ms
// Set bonus (or penalty!) for physical world events
int iSensorBonus = +1;
int iContactBonus = -5;          // Example penalty for triggering contact
long iRootSeed = 61168;          // Initial PRNG starting point

/* ------------------------------------------------------------------------
 GA Structure
 NOTE: Populate in def *mandatory* or death @ runtime. Srsly!
 ------------------------------------------------------------------------
 */
typedef struct GAStruct {
  // Basic DNA
  unsigned long Seed = 0;
  unsigned long Length = 0;
  long Limit = 0;  
  long OutPin = 0;
  long InPin = 0;    
  long OutValue = 0;
  long InValue = 0;  
  long Curve = 0;  
  long Score = 0;
};

GAStruct* GA[16];      // The zoo

/* ------------------------------------------------------------------------
 Globals
 ------------------------------------------------------------------------
 */
int iLedPin = 3;
int iSensorPin = 1;               // Currently a PIR (DIGITAL) sends high while motion
int iSensorLast = 0;              // Most recent reading from sensor
int iContactPin = 4;              // Trigger switch or contact sensor pin
int iServoPin = 0;                // For normalization only, GA must discover what's what
// Runtime
unsigned long lLastTimeMS = 0;    // When (sys run time) current test ends
unsigned long lNowTimeMS = 0;
int iHighScore = 0;
int iHighScoreIndex = 0;
int g; 
int i;

/* ------------------------------------------------------------------------
 Run-Once Setup
 ------------------------------------------------------------------------
 */
void setup () {
  // First generation
  randomSeed (iRootSeed + analogRead (A3));
  for (i=0; i < iZooTotal; i++) {
    fnMutate(i);
    // GA[i]->Length = 32;    // Force reasonable length
    GA[i]->Score = 0;
  }
}

/* ------------------------------------------------------------------------
 Main
 ------------------------------------------------------------------------
 */
void loop () {
  iHighScore = 0;                      // Reset for next run
  randomSeed(GA[i]->Seed);  
  lLastTimeMS = millis();
  
  for (i=0; i < iZooTotal; i++) {
    // Simple mini sim run
    if (millis() - lLastTimeMS < lRunTimeMS) {
      pinMode (GA[i]->OutPin, OUTPUT); // Treat as servo
      digitalWrite (GA[i]->OutPin, HIGH);
      delayMicroseconds (random(8192));
      digitalWrite (GA[i]->OutPin, LOW);      
      delayMicroseconds (random(8192));
      // Scoring
      pinMode (iSensorPin, INPUT);    // Points for trigger PIR
      if (digitalRead (iSensorPin) == HIGH) {
        GA[i]->Score += iSensorBonus;        
      }
      pinMode (iContactPin, INPUT);   // Penalty for trigger Contact
      if (digitalRead (iContactPin) == HIGH) {
        GA[i]->Score += iContactBonus;        
      }      
    } else {                          // End run, rank if highest so far
      if (GA[i]->Score > iHighScore) {
        iHighScore = GA[i]->Score;
        iHighScoreIndex = i;
      }
      fnFlash (i, 20);
      delay(5);    
      iHighScore = 0;                // Reset for next run
      randomSeed(GA[i]->Seed);      
      lLastTimeMS = millis();
    }
  }
  
  // Clone winner, spawn mutant siblings
  fnFlash (iHighScoreIndex, 6000);
  fnClone (iHighScoreIndex);
  for (i=1; i < iZooTotal; i++) {    // Winner unchanged
    fnMutate(i);
  }
}

/* ------------------------------------------------------------------------
 fnMutate : Mutate (arg) GA (by index)
 ------------------------------------------------------------------------
 */
void fnMutate (int iArgIndex) {
  // Some may be completely random  
  GA[iArgIndex]->Seed = random (lRandMax);  
  GA[iArgIndex]->Length = random (lRandMax);  
  GA[iArgIndex]->Limit = random (lRandMax);   
  GA[iArgIndex]->OutPin = random (5);   
  GA[iArgIndex]->InPin = random (5);    
//  GA[iArgIndex]->Curve = random (lRandMax);      
}

/* ------------------------------------------------------------------------
 fnClone : Copy arg1 GA into all other "cages"
 ------------------------------------------------------------------------
 */
void fnClone (int iArgIndex) {
  for (i=0; i < iZooTotal; i++) {
    if (i != iArgIndex) {          // Superfluous
      GA[i]->Seed = GA[iArgIndex]->Seed;
      GA[i]->Length = GA[iArgIndex]->Length;
      GA[i]->Limit = GA[iArgIndex]->Limit;    
      GA[i]->OutPin = GA[iArgIndex]->OutPin;    
      GA[i]->InPin = GA[iArgIndex]->InPin;    
      GA[i]->Curve = GA[iArgIndex]->Curve;          
    }
  }
}

/* ------------------------------------------------------------------------
 fnFlash : Simple flasher
 ------------------------------------------------------------------------
 */
void fnFlash (int iTimes, float iDelaySeconds) {
  if (iTimes < 1) { 
    return; 
  }
  pinMode (iLedPin, OUTPUT);  
  digitalWrite (iLedPin, LOW);      // Start off
  // delayMicroseconds (iDelay);  
  for (int i=0; i < iTimes; i++) {
    digitalWrite (iLedPin, HIGH);
    delayMicroseconds (iDelaySeconds);
    digitalWrite (iLedPin, LOW);
    delayMicroseconds (iDelaySeconds);
  }
}
